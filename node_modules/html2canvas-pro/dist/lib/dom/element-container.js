"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementContainer = void 0;
const index_1 = require("../css/index");
const bounds_1 = require("../css/layout/bounds");
const node_type_guards_1 = require("./node-type-guards");
const debugger_1 = require("../core/debugger");
const dom_normalizer_1 = require("./dom-normalizer");
class ElementContainer {
    constructor(context, element, options = {}) {
        this.context = context;
        this.textNodes = [];
        this.elements = [];
        this.flags = 0;
        if ((0, debugger_1.isDebugging)(element, 3 /* DebuggerType.PARSE */)) {
            debugger;
        }
        this.styles = new index_1.CSSParsedDeclaration(context, context.config.window.getComputedStyle(element, null));
        // Side effects moved to DOMNormalizer (can be disabled via options)
        const shouldNormalize = options.normalizeDom !== false; // Default: true
        if (shouldNormalize && (0, node_type_guards_1.isHTMLElementNode)(element)) {
            this.originalStyles = dom_normalizer_1.DOMNormalizer.normalizeElement(element, this.styles);
            this.originalElement = element; // Save reference for restoration
        }
        this.bounds = (0, bounds_1.parseBounds)(this.context, element);
        if ((0, debugger_1.isDebugging)(element, 4 /* DebuggerType.RENDER */)) {
            this.flags |= 16 /* FLAGS.DEBUG_RENDER */;
        }
    }
    /**
     * Restore original element styles (if normalized)
     * Call this after rendering is complete to clean up DOM state
     */
    restore() {
        if (this.originalStyles && this.originalElement) {
            dom_normalizer_1.DOMNormalizer.restoreElement(this.originalElement, this.originalStyles);
            // Clear references to prevent memory leaks
            this.originalStyles = undefined;
            this.originalElement = undefined;
        }
    }
    /**
     * Recursively restore all elements in the tree
     * Call this on the root container after rendering is complete
     */
    restoreTree() {
        this.restore();
        // Recursively restore all child elements
        for (const child of this.elements) {
            child.restoreTree();
        }
    }
}
exports.ElementContainer = ElementContainer;
//# sourceMappingURL=element-container.js.map