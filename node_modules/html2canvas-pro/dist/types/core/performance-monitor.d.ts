import { Context } from './context';
/**
 * Performance Metric
 *
 * Represents a single performance measurement
 */
export interface PerformanceMetric {
    name: string;
    startTime: number;
    endTime?: number;
    duration?: number;
    metadata?: Record<string, any>;
}
/**
 * Performance Summary
 *
 * Aggregated performance data
 */
export interface PerformanceSummary {
    totalDuration: number;
    metrics: PerformanceMetric[];
    breakdown: Array<{
        name: string;
        duration: number;
        percentage: string;
    }>;
}
/**
 * Performance Monitor
 *
 * Tracks performance metrics throughout the rendering pipeline.
 * Provides insights into where time is spent during rendering.
 *
 * Usage:
 * ```typescript
 * const monitor = new PerformanceMonitor(context);
 *
 * monitor.start('clone');
 * await cloneDocument();
 * monitor.end('clone');
 *
 * const summary = monitor.getSummary();
 * ```
 */
export declare class PerformanceMonitor {
    private readonly context;
    private readonly activeMetrics;
    private readonly completedMetrics;
    private readonly enabled;
    private readonly getTime;
    constructor(context: Context | null, enabled?: boolean);
    /**
     * Start measuring a performance metric
     *
     * @param name - Unique name for this metric
     * @param metadata - Optional metadata to attach
     */
    start(name: string, metadata?: Record<string, any>): void;
    /**
     * End measuring a performance metric
     *
     * @param name - Name of the metric to end
     * @returns The completed metric, or undefined if not found
     */
    end(name: string): PerformanceMetric | undefined;
    /**
     * Measure a synchronous function
     *
     * @param name - Name for this measurement
     * @param fn - Function to measure
     * @param metadata - Optional metadata
     * @returns The function's return value
     */
    measure<T>(name: string, fn: () => T, metadata?: Record<string, any>): T;
    /**
     * Measure an asynchronous function
     *
     * @param name - Name for this measurement
     * @param fn - Async function to measure
     * @param metadata - Optional metadata
     * @returns Promise resolving to the function's return value
     */
    measureAsync<T>(name: string, fn: () => Promise<T>, metadata?: Record<string, any>): Promise<T>;
    /**
     * Get all completed metrics
     *
     * @returns Array of completed performance metrics
     */
    getMetrics(): PerformanceMetric[];
    /**
     * Get a specific metric by name
     *
     * @param name - Metric name
     * @returns The metric, or undefined if not found
     */
    getMetric(name: string): PerformanceMetric | undefined;
    /**
     * Get performance summary
     *
     * @returns Aggregated performance data
     */
    getSummary(): PerformanceSummary;
    /**
     * Log performance summary to console
     */
    logSummary(): void;
    /**
     * Clear all metrics
     */
    clear(): void;
    /**
     * Check if monitoring is enabled
     */
    isEnabled(): boolean;
    /**
     * Get active (uncompleted) metrics
     * Useful for debugging leaked measurements
     */
    getActiveMetrics(): string[];
}
/**
 * Create a no-op performance monitor for production
 * Has minimal overhead when disabled
 */
export declare class NoOpPerformanceMonitor extends PerformanceMonitor {
    constructor();
    start(): void;
    end(): undefined;
    measure<T>(_name: string, fn: () => T): T;
    measureAsync<T>(_name: string, fn: () => Promise<T>): Promise<T>;
}
